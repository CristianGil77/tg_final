import numpy as np
import cv2
import math
import pandas as pd
import os
import matplotlib.pyplot as plt
import pycuda.driver as cuda
import pycuda.autoinit
import pycuda.gpuarray as gpuarray
from pycuda.compiler import SourceModule

class Ubication:
    def __init__(self, person_height, factor = 0.289):
        """
        Inicializa la clase Ubication con el factor de escala, la altura de la persona y umbrales de distancia y ángulo.

        :param factor: Factor de escala para las distancias.
        :param person_height: Altura de la persona en metros.
        """
        self.factor = factor
        self.person_height = person_height
        self.length_step = person_height * factor

    def calculate_ubication(self, detections, point_cloud_gpu, shape, image):
        """
        Calcula la distancia y el ángulo para cada detección y dibuja esta información en la imagen.

        :param detections: Lista de detecciones con coordenadas del bounding box.
        :param point_cloud_gpu: Mapa de disparidad de la imagen en la GPU.
        :param shape: Forma de la nube de puntos (altura, ancho, canales).
        :param image: Imagen en la que se dibujarán los resultados.
        """
        for detection in detections:
            distance, x, y, angle_degrees = self._calculate_distance_and_angle_gpu(point_cloud_gpu, shape, detection)
            
            detection['distance'] = distance
            detection['angle'] = angle_degrees

            self._draw_ubication(image, distance, angle_degrees, x, y)

    def _calculate_distance_and_angle_gpu(self, point_cloud_gpu, shape, detection):
        """
        Calcula la distancia y el ángulo utilizando la GPU a partir del punto medio de su bounding box en el mapa de disparidad.

        :param point_cloud_gpu: Puntero a la memoria de la nube de puntos en la GPU.
        :param shape: Forma de la nube de puntos (altura, ancho, canales).
        :param detection: Detección con coordenadas del bounding box.
        :return: Distancia al objeto, coordenadas x e y del punto medio del bounding box y el ángulo en grados.
        """
        x_min, y_min, x_max, y_max = map(int, detection['box'])
        x = int(x_min + (x_max - x_min) / 2)
        y = int(y_min + (y_max - y_min) / 2)

        mod = SourceModule("""
        __global__ void calculate_distance_and_angle(float *point_cloud, float *result, int x, int y, int width) {
            int idx = y * width + x;
            float px = point_cloud[3 * idx];
            float py = point_cloud[3 * idx + 1];
            float pz = point_cloud[3 * idx + 2];

            result[0] = sqrt(px * px + py * py + pz * pz);
            result[1] = atan2(px, pz) * 180 / 3.141592653589793;
        }
        """)

        calculate_distance_and_angle = mod.get_function("calculate_distance_and_angle")
        
        # Allocate GPU memory for result
        result_gpu = gpuarray.zeros((2,), dtype=np.float32)
        
        # Execute the kernel
        calculate_distance_and_angle(point_cloud_gpu, result_gpu, np.int32(x), np.int32(y), np.int32(shape[1]), block=(1,1,1), grid=(1,1))

        # Transfer result back to CPU
        result = result_gpu.get()
        distance = result[0]
        angle_degrees = result[1]

        
        return distance, x, y, angle_degrees
    
    def calculate_steps(self, distance):
        """
        Calcula el número de pasos basado en la distancia y la altura de la persona.

        :param distance: Distancia calculada.
        :return: Número de pasos.
        """
        return distance / self.length_step
    
    
    
    def _draw_ubication(self, image, distance, angle_degrees, x, y):
        """
        Dibuja la distancia y el ángulo en la imagen en las coordenadas especificadas.

        :param image: Imagen en la que se dibujarán los resultados.
        :param distance: Distancia calculada al objeto.
        :param angle_degrees: Ángulo calculado en grados.
        :param x: Coordenada x en la imagen.
        :param y: Coordenada y en la imagen.
        """
        cv2.putText(image, f"Distance: {distance:.2f}m", (x, y - 10), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 255, 0), 1)
        cv2.putText(image, f"Angle: {angle_degrees:.2f}", (x, y - 50), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 255, 0), 1)

    @staticmethod
    def save_bbox_to_csv(detections, point_cloud_value):
        """
        Guarda los valores del bounding box y la nube de puntos en un archivo CSV.

        :param detections: Lista de detecciones con coordenadas del bounding box.
        :param point_cloud_value: Mapa de disparidad de la imagen.
        """
        for detection in detections:
            x_min, y_min, x_max, y_max = map(int, detection['box'])
            cropped_arr = point_cloud_value[y_min:y_max, x_min:x_max]

            # Aplanar el arreglo para crear el DataFrame
            flattened_arr = cropped_arr.reshape(-1, cropped_arr.shape[-1])
            df = pd.DataFrame(flattened_arr, columns=[f'col_{i}' for i in range(flattened_arr.shape[1])])

            # Crear un nombre de archivo único
            csv_filename = f'{detection["class"]}.csv'
            count = 1
            while os.path.exists(csv_filename):
                csv_filename = f'{detection["class"]}_{count}.csv'
                count += 1
            
            # Guardar el DataFrame como CSV
            df.to_csv(csv_filename, index=False)

# Ejemplo de uso:
# if __name__ == "__main__":
#     ubication = Ubication(factor=0.3, person_height=1.75)
    
#     # Supongamos que tienes una lista de detecciones y un mapa de disparidad
#     detections = [
#         {"class": "person", "box": [100, 150, 200, 300]},
#         # Más detecciones...
#     ]
#     point_cloud = np.random.rand(480, 640, 3) * 10  # Mapa de disparidad de ejemplo
#     image = np.zeros((480, 640, 3), dtype=np.uint8)  # Imagen de ejemplo

#     # Calcular y dibujar ubicaciones
#     ubication.calculate_ubication(detections, point_cloud, image)

#     # Guardar bounding boxes y valores de la nube de puntos en CSV
#     #ubication.save_bbox_to_csv(detections, point_cloud)

#     # Mostrar la imagen resultante usando Matplotlib
#     plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
#     plt.title("Ubication")
#     plt.axis('off')  # Desactiva los ejes
#     plt.show()